/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$size', '$current', '$[]', '$[]=', '$-', '$<', '$push', '$pop', '$<<', '$>', '$==']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Reducer');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'ConditionalDirectiveTracker');

      var $nesting = [self].concat($parent_nesting), $ConditionalDirectiveTracker_preprocess_conditional_directive$1;

      
      Opal.def(self, '$preprocess_conditional_directive', $ConditionalDirectiveTracker_preprocess_conditional_directive$1 = function $$preprocess_conditional_directive(keyword, target, delimiter, text) {
        var $a, $iter = $ConditionalDirectiveTracker_preprocess_conditional_directive$1.$$p, $yield = $iter || nil, self = this, skip_active = nil, depth = nil, directive_lineno = nil, result = nil, curr_inc_replacement = nil, drop = nil, $writer = nil, adjusted_directive_lineno = nil, depth_change = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
        if (self.skipping == null) self.skipping = nil;
        if (self.conditional_stack == null) self.conditional_stack = nil;
        if (self.lineno == null) self.lineno = nil;
        if (self.include_replacements == null) self.include_replacements = nil;

        if ($iter) $ConditionalDirectiveTracker_preprocess_conditional_directive$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        skip_active = self.skipping;
        depth = self.conditional_stack.$size();
        directive_lineno = self.lineno;
        result = $send(self, Opal.find_super_dispatcher(self, 'preprocess_conditional_directive', $ConditionalDirectiveTracker_preprocess_conditional_directive$1, false), $zuper, $iter);
        if ($truthy(($truthy($a = self.skipping) ? skip_active : $a))) {
          return result};
        curr_inc_replacement = self.include_replacements.$current();
        drop = ($truthy($a = curr_inc_replacement['$[]']("drop")) ? $a : (($writer = ["drop", []]), $send(curr_inc_replacement, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        adjusted_directive_lineno = $rb_minus(directive_lineno, ($truthy($a = curr_inc_replacement['$[]']("offset")) ? $a : (($writer = ["offset", 0]), $send(curr_inc_replacement, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])));
        if ($truthy($rb_lt((depth_change = $rb_minus(self.conditional_stack.$size(), depth)), 0))) {
          if ($truthy(skip_active)) {
            $send(drop, 'push', Opal.to_a(Opal.Range.$new(drop.$pop(), adjusted_directive_lineno, false)))
          } else {
            drop['$<<'](adjusted_directive_lineno)
          }
        } else if ($truthy(($truthy($a = $rb_gt(depth_change, 0)) ? $a : directive_lineno['$=='](self.lineno)))) {
          drop['$<<'](adjusted_directive_lineno)
        } else {
          drop['$<<']([adjusted_directive_lineno, text])
        };
        return result;
      }, $ConditionalDirectiveTracker_preprocess_conditional_directive$1.$$arity = 4)
    })($nesting[0], $nesting)
  })($$($nesting, 'Asciidoctor'), $nesting)
})(Opal);

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$send', '$singleton_class', '$instance_variable_set', '$extend', '$[]=', '$-', '$[]', '$end_with?', '$peek_line', '$!', '$start_with?', '$==', '$include?', '$sub', '$push_include_replacement', '$clear', '$size', '$>', '$lines', '$key?', '$empty?', '$private', '$up', '$<<', '$pointer', '$current', '$to_end', '$private_constant']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Reducer');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'IncludeDirectiveTracker');

      var $nesting = [self].concat($parent_nesting), $IncludeDirectiveTracker_extended$1, $IncludeDirectiveTracker_preprocess_include_directive$2, $IncludeDirectiveTracker_push_include$3, $IncludeDirectiveTracker_pop_include$4, $IncludeDirectiveTracker_push_include_replacement$5;

      
      Opal.defs(self, '$extended', $IncludeDirectiveTracker_extended$1 = function $$extended(instance) {
        var self = this;

        
        instance.$singleton_class().$send("attr_reader", "include_replacements");
        instance.$instance_variable_set("@include_replacements", [$hash2([], {})].$extend($$($nesting, 'CurrentPosition')));
        return instance.$instance_variable_set("@x_reducer", $hash2([], {}));
      }, $IncludeDirectiveTracker_extended$1.$$arity = 1);
      
      Opal.def(self, '$preprocess_include_directive', $IncludeDirectiveTracker_preprocess_include_directive$2 = function $$preprocess_include_directive(target, attrlist) {
        var $a, $b, $c, $d, $e, $iter = $IncludeDirectiveTracker_preprocess_include_directive$2.$$p, $yield = $iter || nil, self = this, $writer = nil, directive_lineno = nil, result = nil, ln = nil, unresolved = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
        if (self.x_reducer == null) self.x_reducer = nil;
        if (self.lineno == null) self.lineno = nil;

        if ($iter) $IncludeDirectiveTracker_preprocess_include_directive$2.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $writer = ["include_directive_line", "" + "include::" + (target) + "[" + (attrlist) + "]"];
        $send(self.x_reducer, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["include_pushed", false];
        $send(self.x_reducer, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        directive_lineno = self.lineno;
        result = $send(self, Opal.find_super_dispatcher(self, 'preprocess_include_directive', $IncludeDirectiveTracker_preprocess_include_directive$2, false), $zuper, $iter);
        if ($truthy(self.x_reducer['$[]']("include_pushed"))) {
        } else {
          
          if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = ($e = (ln = self.$peek_line(true)), ($e === nil || $e == null) ? nil : $send($e, 'end_with?', ["]"]))) ? (unresolved = ln['$start_with?']("Unresolved directive in "))['$!']() : $d)) ? directive_lineno['$=='](self.lineno) : $c)) ? (unresolved = ln['$start_with?']("link:")) : $b)) ? ln['$include?']("[role=")['$!']() : $a))) {
            ln = ln.$sub("[", "" + "[role=include" + ((function() {if (ln['$[]'](-2)['$==']("[")) {
              return ""
            } else {
              return ","
            }; return nil; })()))};
          self.$push_include_replacement(directive_lineno, (function() {if ($truthy(unresolved)) {
            return [ln]
          } else {
            return []
          }; return nil; })(), 0, unresolved);
        };
        self.x_reducer.$clear();
        return result;
      }, $IncludeDirectiveTracker_preprocess_include_directive$2.$$arity = 2);
      
      Opal.def(self, '$push_include', $IncludeDirectiveTracker_push_include$3 = function $$push_include(data, file, path, lineno, attrs) {
        var $a, $b, $iter = $IncludeDirectiveTracker_push_include$3.$$p, $yield = $iter || nil, self = this, $writer = nil, directive_lineno = nil, prev_inc_depth = nil, offset = nil, result = nil, inc_lines = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
        if (self.x_reducer == null) self.x_reducer = nil;
        if (self.lineno == null) self.lineno = nil;
        if (self.include_stack == null) self.include_stack = nil;

        if ($iter) $IncludeDirectiveTracker_push_include$3.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $writer = ["include_pushed", true];
        $send(self.x_reducer, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        directive_lineno = $rb_minus(self.lineno, 1);
        prev_inc_depth = self.include_stack.$size();
        offset = (function() {if ($truthy($rb_gt(lineno, 1))) {
          return $rb_minus(lineno, 1)
        } else {
          return 0
        }; return nil; })();
        result = $send(self, Opal.find_super_dispatcher(self, 'push_include', $IncludeDirectiveTracker_push_include$3, false), $zuper, $iter);
        if ($truthy($rb_gt(self.include_stack.$size(), prev_inc_depth))) {
          
          inc_lines = self.$lines();
          if ($truthy(($truthy($a = ($truthy($b = attrs['$key?']("leveloffset")) ? inc_lines['$[]'](0)['$start_with?'](":leveloffset: ") : $b)) ? ($b = inc_lines['$[]'](1), ($b === nil || $b == null) ? nil : $send($b, 'empty?', [])) : $a))) {
            offset = $rb_minus(offset, 2)};};
        self.$push_include_replacement(directive_lineno, ($truthy($a = inc_lines) ? $a : []), offset);
        return result;
      }, $IncludeDirectiveTracker_push_include$3.$$arity = 5);
      self.$private();
      
      Opal.def(self, '$pop_include', $IncludeDirectiveTracker_pop_include$4 = function $$pop_include() {
        var $iter = $IncludeDirectiveTracker_pop_include$4.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
        if (self.x_reducer == null) self.x_reducer = nil;
        if (self.include_replacements == null) self.include_replacements = nil;

        if ($iter) $IncludeDirectiveTracker_pop_include$4.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        if ($truthy(self.x_reducer['$[]']("include_pushed"))) {
        } else {
          self.include_replacements.$up()
        };
        return $send(self, Opal.find_super_dispatcher(self, 'pop_include', $IncludeDirectiveTracker_pop_include$4, false), $zuper, $iter);
      }, $IncludeDirectiveTracker_pop_include$4.$$arity = 0);
      
      Opal.def(self, '$push_include_replacement', $IncludeDirectiveTracker_push_include_replacement$5 = function $$push_include_replacement(lineno, lines, offset, unresolved) {
        var $a, self = this, inc_replacements = nil, $logical_op_recvr_tmp_1 = nil, $writer = nil;
        if (self.include_replacements == null) self.include_replacements = nil;
        if (self.x_reducer == null) self.x_reducer = nil;

        
        
        if (unresolved == null) {
          unresolved = false;
        };
        (inc_replacements = self.include_replacements)['$<<']($hash2(["into", "lineno", "line", "lines", "offset"], {"into": inc_replacements.$pointer(), "lineno": $rb_minus(lineno, (($logical_op_recvr_tmp_1 = inc_replacements.$current()), ($truthy($a = $logical_op_recvr_tmp_1['$[]']("offset")) ? $a : (($writer = ["offset", 0]), $send($logical_op_recvr_tmp_1, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])))), "line": self.x_reducer['$[]']("include_directive_line"), "lines": lines, "offset": offset}));
        if ($truthy(($truthy($a = unresolved) ? $a : lines['$empty?']()))) {
        } else {
          inc_replacements.$to_end()
        };
        return nil;
      }, $IncludeDirectiveTracker_push_include_replacement$5.$$arity = -4);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'CurrentPosition');

      var $nesting = [self].concat($parent_nesting), $CurrentPosition_extended$6, $CurrentPosition_current$7, $CurrentPosition_to_end$8, $CurrentPosition_up$9;

      
      Opal.defs(self, '$extended', $CurrentPosition_extended$6 = function $$extended(instance) {
        var self = this;

        
        instance.$singleton_class().$send("attr_reader", "pointer");
        return instance.$to_end();
      }, $CurrentPosition_extended$6.$$arity = 1);
      
      Opal.def(self, '$current', $CurrentPosition_current$7 = function $$current() {
        var self = this;
        if (self.pointer == null) self.pointer = nil;

        return self['$[]'](self.pointer)
      }, $CurrentPosition_current$7.$$arity = 0);
      
      Opal.def(self, '$to_end', $CurrentPosition_to_end$8 = function $$to_end() {
        var self = this;

        return (self.pointer = $rb_minus(self.$size(), 1))
      }, $CurrentPosition_to_end$8.$$arity = 0);
      
      Opal.def(self, '$up', $CurrentPosition_up$9 = function $$up() {
        var self = this;

        return (self.pointer = self.$current()['$[]']("into"))
      }, $CurrentPosition_up$9.$$arity = 0);
    })($nesting[0], $nesting);
    self.$private_constant("CurrentPosition");
  })($$($nesting, 'Asciidoctor'), $nesting)
})(Opal);

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$method_defined?', '$singleton_class', '$send', '$each_with_object', '$[]', '$[]=', '$-']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Reducer');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'HeaderAttributeTracker');

      var $nesting = [self].concat($parent_nesting), $HeaderAttributeTracker_extended$1, $HeaderAttributeTracker_finalize_header$2;

      
      Opal.defs(self, '$extended', $HeaderAttributeTracker_extended$1 = function $$extended(instance) {
        var self = this;

        
        if ($truthy(instance.$singleton_class()['$method_defined?']("source_header_attributes"))) {
          return nil};
        return instance.$singleton_class().$send("attr_reader", "source_header_attributes");
      }, $HeaderAttributeTracker_extended$1.$$arity = 1);
      
      Opal.def(self, '$finalize_header', $HeaderAttributeTracker_finalize_header$2 = function $$finalize_header($a) {
        var $post_args, $$3, $iter = $HeaderAttributeTracker_finalize_header$2.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
        if (self.attributes_modified == null) self.attributes_modified = nil;

        if ($iter) $HeaderAttributeTracker_finalize_header$2.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        ;
        self.source_header_attributes = $send(self.attributes_modified, 'each_with_object', [$hash2([], {})], ($$3 = function(name, accum){var self = $$3.$$s || this, $writer = nil;
          if (self.attributes == null) self.attributes = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (accum == null) {
            accum = nil;
          };
          $writer = [name, self.attributes['$[]'](name)];
          $send(accum, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$3.$$s = self, $$3.$$arity = 2, $$3));
        return $send(self, Opal.find_super_dispatcher(self, 'finalize_header', $HeaderAttributeTracker_finalize_header$2, false), $zuper, $iter);
      }, $HeaderAttributeTracker_finalize_header$2.$$arity = -1);
    })($nesting[0], $nesting)
  })($$($nesting, 'Asciidoctor'), $nesting)
})(Opal);

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$==', '$[]', '$options', '$extend']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Reducer');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Preprocessor');

      var $nesting = [self].concat($parent_nesting), $Preprocessor_process$1;

      return (Opal.def(self, '$process', $Preprocessor_process$1 = function $$process(doc, reader) {
        var self = this;

        if ($truthy(doc.$options()['$[]']("preserve_conditionals"))) {
          
          return reader.$extend($$($nesting, 'IncludeDirectiveTracker'));
        } else {
          
          return reader.$extend($$($nesting, 'ConditionalDirectiveTracker'), $$($nesting, 'IncludeDirectiveTracker'));
        }
      }, $Preprocessor_process$1.$$arity = 2), nil) && 'process'
    })($nesting[0], $$$($$$($$$('::', 'Asciidoctor'), 'Extensions'), 'Preprocessor'), $nesting)
  })($$($nesting, 'Asciidoctor'), $nesting);
})(Opal);

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$>', '$size', '$include_replacements', '$reader', '$!', '$empty?', '$[]', '$dup', '$source_lines', '$[]=', '$-', '$reverse_each', '$==', '$error', '$logger', '$===', '$delete_at', '$flatten', '$sourcemap', '$merge', '$options', '$new', '$groups', '$catalog', '$load', '$parse', '$logger=', '$pop', '$replace', '$private', '$raise', '$length', '$<', '$+', '$<<']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Reducer');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'TreeProcessor');

      var $nesting = [self].concat($parent_nesting), $TreeProcessor_process$1, $TreeProcessor_flatten$4;

      
      
      Opal.def(self, '$process', $TreeProcessor_process$1 = function $$process(doc) {
        var $a, $b, $$2, self = this, inc_replacements = nil, $writer = nil, reduced_source_lines = nil, logger = nil, opts = nil, ext_reg = nil, includes = nil;

        
        if ($truthy(($truthy($a = $rb_gt((inc_replacements = doc.$reader().$include_replacements()).$size(), 1)) ? $a : ($truthy($b = inc_replacements['$[]'](0)['$[]']("drop")) ? $b : [])['$empty?']()['$!']()))) {
          
          
          $writer = ["lines", doc.$source_lines().$dup()];
          $send(inc_replacements['$[]'](0), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          $send(inc_replacements, 'reverse_each', [], ($$2 = function(it){var self = $$2.$$s || this, $c, $$3, into = nil, target_lines = nil, idx = nil, msg = nil, lines = nil, drop = nil;

          
            
            if (it == null) {
              it = nil;
            };
            if ($truthy((into = it['$[]']("into")))) {
              
              target_lines = inc_replacements['$[]'](into)['$[]']("lines");
              if (target_lines['$[]']((idx = $rb_minus(it['$[]']("lineno"), 1)))['$=='](it['$[]']("line"))) {
              } else {
                
                msg = "" + "include directive to reduce not found; expected: \"" + (it['$[]']("line")) + "\"; got: \"" + (target_lines['$[]'](idx)) + "\"";
                doc.$logger().$error(msg);
                return nil;;
              };};
            lines = it['$[]']("lines");
            if ($truthy((drop = ($truthy($c = it['$[]']("drop")) ? $c : []))['$empty?']())) {
            } else {
              $send(drop, 'reverse_each', [], ($$3 = function(drop_it){var self = $$3.$$s || this;

              
                
                if (drop_it == null) {
                  drop_it = nil;
                };
                if ($truthy($$$('::', 'Array')['$==='](drop_it))) {
                  
                  
                  $writer = [$rb_minus(drop_it['$[]'](0), 1), drop_it['$[]'](1)];
                  $send(lines, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];;
                } else {
                  
                  return lines.$delete_at($rb_minus(drop_it, 1));
                };}, $$3.$$s = self, $$3.$$arity = 1, $$3))
            };
            if ($truthy(target_lines)) {
              
              $writer = [idx, lines];
              $send(target_lines, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            } else {
              return nil
            };}, $$2.$$s = self, $$2.$$arity = 1, $$2));
          if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
            reduced_source_lines = self.$flatten(inc_replacements['$[]'](0)['$[]']("lines"))
          } else {
            nil
          };
          if ($truthy(doc.$sourcemap())) {
            
            logger = doc.$logger();
            opts = doc.$options().$merge($hash2(["logger", "parse", "reduced"], {"logger": nil, "parse": false, "reduced": true}));
            if ($truthy((ext_reg = opts['$[]']("extension_registry")))) {
              
              $writer = ["extension_registry", $$$($$$($$$('::', 'Asciidoctor'), 'Extensions'), 'Registry').$new(ext_reg.$groups())];
              $send(opts, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            includes = doc.$catalog()['$[]']("includes");
            doc = $$$('::', 'Asciidoctor').$load(reduced_source_lines, opts);
            
            $writer = ["includes", includes];
            $send(doc.$catalog(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            doc.$parse();
            
            $writer = [logger];
            $send($$$($$$('::', 'Asciidoctor'), 'LoggerManager'), 'logger=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else {
            
            while (reduced_source_lines['$[]'](-1)['$==']("")) {
              reduced_source_lines.$pop()
            };
            doc.$source_lines().$replace(reduced_source_lines);
          };};
        return doc;
      }, $TreeProcessor_process$1.$$arity = 1);
      self.$private();
      if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
        return (Opal.def(self, '$flatten', $TreeProcessor_flatten$4 = function $$flatten(input_list) {
          var $a, $b, $c, self = this, e = nil, result = nil, stack = nil, idx = nil, list = nil, len = nil, item = nil, next_idx = nil;

          try {
            return input_list.$flatten()
          } catch ($err) {
            if (Opal.rescue($err, [$$$('::', 'Exception')])) {e = $err;
              try {
                
                if ($truthy(($truthy($a = e) ? (e.name)['$==']("RangeError") : $a))) {
                } else {
                  self.$raise()
                };
                result = [];
                stack = [[0, input_list, input_list.$length()]];
                while (!($truthy(stack['$empty?']()))) {
                  
                  $c = stack.$pop(), $b = Opal.to_ary($c), (idx = ($b[0] == null ? nil : $b[0])), (list = ($b[1] == null ? nil : $b[1])), (len = ($b[2] == null ? nil : $b[2])), $c;
                  while ($truthy($rb_lt(idx, len))) {
                    if ($truthy($$($nesting, 'Array')['$===']((item = list['$[]'](idx))))) {
                      
                      if ($truthy($rb_lt((next_idx = $rb_plus(idx, 1)), len))) {
                        stack['$<<']([next_idx, list, len])};
                      idx = 0;
                      len = (list = item).$length();
                    } else {
                      
                      result['$<<'](item);
                      idx = $rb_plus(idx, 1);
                    }
                  };
                };
                return result;
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, $TreeProcessor_flatten$4.$$arity = 1), nil) && 'flatten'
      } else {
        return nil
      };
    })($nesting[0], $$$($$$($$$('::', 'Asciidoctor'), 'Extensions'), 'TreeProcessor'), $nesting)
  })($$($nesting, 'Asciidoctor'), $nesting)
})(Opal);

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$==', '$module_function', '$proc', '$extend', '$document', '$[]', '$options', '$preprocessor', '$tree_processor', '$===', '$create', '$to_proc', '$groups', '$key', '$group', '$[]=', '$-', '$delete']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Reducer');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Extensions');

      var $nesting = [self].concat($parent_nesting), $Extensions_group$1, $Extensions_key$3, $Extensions_prepare_registry$4, $Extensions_register$5, $Extensions_unregister$6;

      
      self.$module_function();
      
      Opal.def(self, '$group', $Extensions_group$1 = function $$group() {
        var $$2, self = this;

        return $send(self, 'proc', [], ($$2 = function(){var self = $$2.$$s || this;

        
          self.$document().$extend($$($nesting, 'HeaderAttributeTracker'));
          if ($truthy(self.$document().$options()['$[]']("reduced"))) {
            return nil;};
          self.$preprocessor($$($nesting, 'Preprocessor'));
          self.$tree_processor($$($nesting, 'TreeProcessor'));
          return nil;}, $$2.$$s = self, $$2.$$arity = 0, $$2))
      }, $Extensions_group$1.$$arity = 0);
      
      Opal.def(self, '$key', $Extensions_key$3 = function $$key() {
        var self = this;

        return "reducer"
      }, $Extensions_key$3.$$arity = 0);
      
      Opal.def(self, '$prepare_registry', $Extensions_prepare_registry$4 = function $$prepare_registry(registry) {
        var self = this, $writer = nil;

        
        
        if (registry == null) {
          registry = nil;
        };
        if ($truthy($$$('::', 'Proc')['$==='](registry))) {
          registry = $send($$$($$$('::', 'Asciidoctor'), 'Extensions'), 'create', [], registry.$to_proc())};
        if ($truthy($$$($$$('::', 'Asciidoctor'), 'Extensions').$groups()['$[]'](self.$key()))) {
          return registry};
        if ($truthy(registry)) {
          
          
          $writer = [self.$key(), self.$group()];
          $send(registry.$groups(), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return registry;
        } else {
          return $send($$$($$$('::', 'Asciidoctor'), 'Extensions'), 'create', [self.$key()], self.$group().$to_proc())
        };
      }, $Extensions_prepare_registry$4.$$arity = -1);
      
      Opal.def(self, '$register', $Extensions_register$5 = function $$register(registry) {
        var $a, self = this, $logical_op_recvr_tmp_2 = nil, $writer = nil;

        
        
        if (registry == null) {
          registry = nil;
        };
        $logical_op_recvr_tmp_2 = ($truthy($a = registry) ? $a : $$$($$$('::', 'Asciidoctor'), 'Extensions')).$groups();
        return ($truthy($a = $logical_op_recvr_tmp_2['$[]'](self.$key())) ? $a : (($writer = [self.$key(), self.$group()]), $send($logical_op_recvr_tmp_2, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      }, $Extensions_register$5.$$arity = -1);
      
      Opal.def(self, '$unregister', $Extensions_unregister$6 = function $$unregister(registry) {
        var $a, self = this;

        
        
        if (registry == null) {
          registry = nil;
        };
        ($truthy($a = registry) ? $a : $$$($$$('::', 'Asciidoctor'), 'Extensions')).$groups().$delete(self.$key());
        return nil;
      }, $Extensions_unregister$6.$$arity = -1);
    })($nesting[0], $nesting)
  })($$($nesting, 'Asciidoctor'), $nesting);
})(Opal);
